task1

-----

子类只能从被扩展的父类获得成员变量、方法、和内部类（包括内部接口、枚举），不能获得构造器和初始化块

但是子类初始化时，首先会进行父类的初始化，并且会调用构造器（在子类类初始化过后）产生一个父类的实例（这个实例时隐藏的），所以用super在构造器里面使用时是显示调用父类构造器（不然就是隐式调用父类的无参数构造器）

总结一下：无论如何，当调用子类构造器来初始化子类对象的时候，父类构造器总会在子类构造器之前运行。

##### 讲讲什么是重写/重载，以及它们的作用。

重写就是覆盖父类的方法（其实也不完全是覆盖，用super还是可以调用到父类的），要求两同两小一大：

###### 方法名、形参相同，方法返回值、子类方法声明抛出的异常类更小，子类方法访问权限更大。

重载就不是局限在子类父类里面了，老实说子类写了和父类名字相同的方法不能说成重载，这种应该是定义了一个新的方法，重载（overload）一般是同一个类的多个方法之间，形参不同，（注意只有返回值不同并不能产生重载，因为编译器无法确定你找的是哪个方法，编译器糊涂了你就完了）

task2

----------

##### 讲讲什么是抽象类，它和普通的类有什么区别，有什么作用。

抽象类是对一系列类的有相似功能的类的提炼，它有所有的成员，包含成员变量、方法（普通方法和抽象方法）、构造器、初始化块、内部类（接口、枚举）。但是它的构造器不能用来创造自己的实例，只能被子类调用，它必须被继承。

简单来说，它是从多个具有相同特征的类中抽象出来的一个模板，规定了子类的行为模式，，而且，它还可以实现将行为的具体模式推迟到子类中具体实现，主要我们在其它地方调用到这种抽象方法的时候，可以先不知道方法的具体内容。

e.g.![image-20220907102354398](C:\Users\yuanz\AppData\Roaming\Typora\typora-user-images\image-20220907102354398.png)

![image-20220907102543762](C:\Users\yuanz\AppData\Roaming\Typora\typora-user-images\image-20220907102543762.png)

##### 众所周知，下界合金剑NetheriteSword是基于钻石剑DiamondSword合成的。尝试让`NetheriteSword`既继承`Sword`又继承`DiamondSword`。发生了什么？为什么？

无法继承，一个类只能直接继承一个父类，如果非要这样，就让netheriteSword继承diamondSword，这样间接父类就是Sword了

task3

------------------------------

##### Q1. 学习关于java的接口的知识，讲讲接口和抽象类有什么区别？接口有什么用处？

接口：

1、是一个同一规范，它规定一批类必须提供某些方法，正常来说，接口不提供任何实现，相当于是做到将规范和实现分离的操作。因此，接口不包含构造器和初始化块定义，而且接口里面的成员变量只能是静态（static）常量。

2、既然是公共的行为规范，那么接口里面的常量、方法、内部类和内部枚举都只能是public

3、不过有点异于常理的是，在java8以后，允许在接口里定义默认方法和类方法，java9后还增加了私有方法作为工具方法（仅在接口里面使用）。原本有实现的方法不应该出现在接口里，这里可能是因为实际有些不规范导致需要，所有java不得不新增（我猜的哈，不知道对不对），因为不管怎么看，这个default方法就是和实例方法一样的，而类方法就更是了，

#### 区别

所以你看，java9以后的接口和抽象类好像就只有构造器和访问控制符的区别，但实际上区别是很大的。

###### 接口作为系统和外界交互的窗口，体现的是一种规范，规定了实现者必须向**外界**提供哪些服务（以方法的形式来提供）。当一个程序中使用接口时，接口是多个模块之间的耦合标准；当多个应用程序之间使用接口时，接口是多个程序之间的通信标准。

##### 然而对于抽象类，它是类似于整个系统的“总纲：，一种模板式的设计，它可以被认为是系统实现过程中的中间产品，这个中间产品已经实现了部分功能（即那些已经提供了方法体的方法），而这个中间体还需要继续加工产生一个个子类来产生最终产品。



至于语法上的许多不同，那就不必赘述，可以网上查。

其实这样就能看明白，为什么我们在创造Sword类的时候采用抽象类而不是模板，因为Sword类其实已经实现了sword的大部分功能，只是对于附魔操作需要被相应的子类给出实现，而对于物品来说，物品千千万万，各自的方法具体实现无法捉摸，同样是”**用**“这个行为，对于刀和枪的用明显不同，但是我们人物都只有用这个方法来对对象操作，所以就提供接口，



##### Q3. 可以让三种矿物既实现`Item`接口又实现`Mineral`接口吗？实现它。这和类的继承的此类特性有什么区别？

可以，一个类可以同时实现多个接口

task4

----------------

  if (!hasDiamondSword) { *// 没有钻石剑，好害怕，先挖矿！*

​        for (Item item : inventory) {

​          if (item instanceof Diamond && ((Diamond) item).count >= 10) {

​            Game.make(2);

​            hasDiamondSword = true;

​            *//肯定是要附魔呀*

​            for(Item item_s : Game.player.inventory){

​              if(item_s instanceof Sword){

​                for(int i=0;i<4;i++){

​                ((Sword)item_s).enchant();*//这里其实有多态的特征,嘿嘿使劲附魔*

​                }

​                break;

​              }

​            }

​            break;

​          }

​        }

​        if (hasDiamondSword)

​          continue;

​        Game.mine();

​        continue;

​      }

​      Monster nextMonster = Game.getNextMonster();

​      *// 如果下一只怪是苦力怕，而且我还不饿,赶紧跑！*

​      if (nextMonster instanceof Creeper && hunger >= 10) {

​        nextMonster.runAway();

​        continue;

​      }

​      *// 有钻石剑且状态良好，直接莽！*

​      if (hunger > 10 && health > 10) {

​        nextMonster.attack();

​        continue;

​      }

​      for (Item item : inventory) { *// 状态不好，补充状态！*

​        if ((item instanceof Eatable && ((Eatable) item).count > 0)) {

​          ((Eatable) item).eat();

​        }

​      }

​      Game.adventure(); *// 打不了怪就去收集食物吧*

====================================================================-------------------------------------------------------------------------------------



  if (!hasDiamondSword) { *// 没有钻石剑，好害怕，先挖矿！*

​        for (Item item : inventory) {

​          if (item instanceof Diamond && ((Diamond) item).count >= 10) {

​            Game.make(2);

​            hasDiamondSword = true;

​            break;

​          }

​        }

​        if (hasDiamondSword)

​          continue;

​        Game.mine();

​        continue;

​      }

​      Monster nextMonster = Game.getNextMonster();

​      *// 如果下一只怪是苦力怕，而且我还不饿,赶紧跑！*

​      if (nextMonster instanceof Creeper && hunger >= 10) {

​        nextMonster.runAway();

​        continue;

​      }

​      *// 有钻石剑且状态良好，直接莽！*

​      if (hunger >= 10 && health >= 10) {

​        nextMonster.attack();

​        continue;

​      }

​      for (Item item : inventory) { *// 状态不好，补充状态！*

​        if ((item instanceof Eatable && ((Eatable) item).count > 0)) {

​          while(((Eatable) item).count>0){

​          ((Eatable) item).eat();

​          ((Eatable) item).count--;

​          }

​        }

​      }

​      *//如果都是末影龙了，就拼了*

​      if(health>=4&&hunger>=4&&nextMonster instanceof EnderDragon){

​        nextMonster.attack();

​        continue;

​      }

​      Game.adventure(); *// 打不了怪就去收集食物吧*



​    }

  }

，这个没有用附魔，用附魔的方法确实太bug了

![image-20220909130109297](C:\Users\yuanz\AppData\Roaming\Typora\typora-user-images\image-20220909130109297.png)

#### 了解java的多态机制，谈谈你的理解。

其实就是引用变量的编译时类型和运行类型不一致，编译时类型时BaseClass,而运行时类型时SubClass，当引用变量调用Baseclass的方法的时候子类的方法覆盖了父类，所以表现出来就是子类的方法，比如，![image-20220907155501304](C:\Users\yuanz\AppData\Roaming\Typora\typora-user-images\image-20220907155501304.png)

这里item虽然是Sword的类型，然而运行时实际上对应到了DiomendSword，是Sword的子类，所以Sword的enchant（）方法不会执行而是执行这个子类的（当然这里并不是那么严谨，因为Sword实际上是抽象类，所以不可能会执行到它的抽象方法)但这也正是抽象类的实现原理，利用多态使得相同类型的引用变量在指向具体子类过后有各自不同的实现

#### 了解“耦合”、“内聚”、“封装”的概念，结合本题谈谈类的继承、抽象类、接口等都有些什么意义。

首先要知道一个软件是由多个子程序组装而成,
而一个程序由多个模块(方法)构成!
**内聚**就是指**程序内**的各个模块之间的**关系紧密程度**,
**耦合**就是各个**外部程序**(子程序)**之间**的关系紧密程度.
所以很易明白,为什么**要高内聚**?**模块之间的关系越紧密,出错就越少!**                       **低耦合?**子**程序间的关系越复杂,就会产生更多的意想不到的错误!**                            会给以后的维护工作带来很多麻烦!

　**封装性**

就是把对象的属性和服务结合成一个独立的相同单位，并尽可能隐蔽对象的内部细节，包含两个含义：
　　◇ <u>把对象的全部属性和全部服务结合在一起</u>，形成一个不可分割的独立单位（即对象）。
　　◇<u>信息隐蔽，即尽可能隐蔽对象的内部细节</u>，对外形成一个边界〔或者说形成一道屏障〕，<u>只保留有限的对外接口使之与外部发生联系。</u>
　　封装的原则在软件上的反映是：<u>要求使对象以外的部分不能**随意存取**对象的内部数据（属性），</u>从而有效的避免了外部错误对它的"交叉感染"，使软件错误能够局部化，大大减少查错和排错的难度。
小结：隐藏属性（成员变量），提供同一方法接口供调用

#### 结合本题谈谈类的继承、抽象类、接口等都有些什么意义。

继承：比如可以吃的东西是一个基础的类，从而由此可以派生许多子类---苹果、蛋糕等等，实现代码（类）高度复用，当然这个会破环父类的封装，所以应该控制一些对父类的访问（通过访问控制符），

抽象类：它是类似于整个系统的“总纲：，一种模板式的设计，它可以被认为是系统实现过程中的中间产品，这个中间产品已经实现了部分功能（即那些已经提供了方法体的方法），而这个中间体还需要继续加工产生一个个子类来产生最终产品        

我们这里的Sword就是一个抽象类，它已经实现了作为sword的大部分方法（其实就只有一个构造器来设置sword威力）和变量（power），然后具体的子类根据这个模板进行完善，对于附魔操作进行完成

接口：作为规范，比如这里的物品item和矿物item接口，它们是一种更抽象的概念，通过interface的规范可以向外部提供统一的调用方法（当然这里并没有写），比如可以加入：“用”，“扔”，“交换”等通用操作

#### 可以发现两人的程序在整合时约定的内容还是非常多，有没有什么可以进一步降低耦合的建议？

1、少使用类的继承，多用接口隐藏实现的细节。 Java面向对象编程引入接口除了支持多态外， 隐藏实现细节也是其中一个目的。

比如我们的eatable也可以用接口来实现，只是需要额外的gethungerRecovery（）来实现获取食物的恢复值，

2、模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。（其实这是高内聚的一种说法，高内聚低耦合一般同时出现）

比如用户可以单独成为一个类，对成员变量进一步封装，提供外部方法来操作数据。

3、遵循一个定义只在一个地方出现。

其实就是代码复用率要高（我认为的哈，这里有点点不懂~👻

4、少使用全局变量。

保证变量的作用范围

5、类属性和方法的声明少用public，多用private关键字。

访问控制符用起来，getxxx、setxxx方法实现更好的用户交互

总的来说，我们这个游戏的封装不够，而且两个人应该是互相提供接口规范来实现更好的低耦合